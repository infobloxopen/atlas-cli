# this file was generated by atlas-cli
# changes to this file will be overriden by atlas-cli update
#
PROJECT_ROOT            ?= $(PWD)
BUILD_PATH              ?= bin
DOCKERFILE_PATH         ?= $(CURDIR)/docker

# configuration for image names
USERNAME                ?= $(USER)
GIT_COMMIT              ?= $(shell git describe --dirty=-unsupported --always --tags || echo pre-commit)
IMAGE_VERSION           ?= $(GIT_COMMIT)-$(USERNAME)

# configuration for server binary and image
SERVER_BINARY           ?= $(BUILD_PATH)/server
SERVER_PATH             ?= $(PROJECT_ROOT)/cmd/server
SERVER_DOCKERFILE       ?= $(DOCKERFILE_PATH)/Dockerfile

# configuration for the protobuf gentool
SRCROOT_ON_HOST         ?= $(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
SRCROOT_IN_CONTAINER    ?= /go/src/$(PROJECT_ROOT)
DOCKER_RUNNER           ?= docker run --rm -u `id -u`:`id -g` -e GOCACHE=/go -e CGO_ENABLED=0 -v $(SRCROOT_ON_HOST):$(SRCROOT_IN_CONTAINER)
DOCKER_GENERATOR        ?= infoblox/atlas-gentool:latest
GENERATOR               ?= $(DOCKER_RUNNER) $(DOCKER_GENERATOR)
SWAGGER_GENERATOR       ?= $(DOCKER_RUNNER) --entrypoint atlas_patch $(DOCKER_GENERATOR)

# configuration for building Go with Docker
GO_IMAGE                ?= golang:1.16-alpine
GO_RUNNER               ?= $(DOCKER_RUNNER) -w $(SRCROOT_IN_CONTAINER) $(GO_IMAGE)

# configuration for building on host machine
export GOFLAGS          ?= -mod=vendor
GO_CACHE                ?= -pkgdir $(BUILD_PATH)/go-cache
GO_BUILD_FLAGS          ?= $(GO_CACHE) -i -v
GO_TEST_FLAGS           ?= -v -cover
GO_PACKAGES             ?= $(shell go list ./... | grep -v vendor)


PROTOBUF_ARGS =  -I=$(PROJECT_ROOT)/vendor
PROTOBUF_ARGS += --go_out=.
PROTOBUF_ARGS += --go-grpc_out=.
PROTOBUF_ARGS += --go-grpc_opt require_unimplemented_servers=false
PROTOBUF_ARGS += --validate_out="lang=go:."
WITH_DATABASE ?= false
WITH_GATEWAY  ?= false

GO_MOD = go.mod

{{ if .WithHelm }}
CHART := {{ .Helm.GetName }}
CHART_VERSION := $(IMAGE_VERSION)
CHART_FILE := $(CHART)-$(CHART_VERSION).tgz
{{end}}

ifeq ($(WITH_DATABASE), true)
PROTOBUF_ARGS += --gorm_out=.
endif

ifeq ($(WITH_GATEWAY), true)
PROTOBUF_ARGS += --grpc-gateway_out=.
PROTOBUF_ARGS += --grpc-gateway_opt logtostderr=true,allow_delete_body=true
PROTOBUF_ARGS += --openapiv2_out=.
PROTOBUF_ARGS += --openapiv2_opt allow_delete_body=true,json_names_for_fields=false
else ifeq ($(WITH_EXPAND), true)
PROTOBUF_ARGS += --grpc-gateway_out=.
PROTOBUF_ARGS += --grpc-gateway_opt logtostderr=true
endif

.PHONY all: all-atlas
all-atlas: vendor-atlas protobuf-atlas docker-atlas

.PHONY fmt: fmt-atlas
fmt-atlas:
	@$(GO_RUNNER) go fmt $(GO_PACKAGES)

.PHONY test: test-atlas
test-atlas: fmt-atlas
	$(GO_RUNNER) go test $(GO_TEST_FLAGS) $(GO_PACKAGES)

docker-atlas:
	@docker build -f $(SERVER_DOCKERFILE) -t $(SERVER_IMAGE):$(IMAGE_VERSION) .
	@docker image prune -f --filter label=stage=server-intermediate

.docker-$(IMAGE_NAME)-$(IMAGE_VERSION):
	$(MAKE) docker-atlas
	touch $@

.PHONY: docker
docker: .docker-$(IMAGE_NAME)-$(IMAGE_VERSION)

push-atlas: docker
ifndef IMAGE_REGISTRY
	@(echo "Please set IMAGE_REGISTRY variable in Makefile.vars to use push command"; exit 1)
else
	@docker push $(SERVER_IMAGE):$(IMAGE_VERSION)
endif

.push-$(IMAGE_NAME)-$(IMAGE_VERSION):
	$(MAKE) push-atlas
	touch $@

.PHONY: push
push: .push-$(IMAGE_NAME)-$(IMAGE_VERSION)

.PHONY protobuf: protobuf-atlas
protobuf-atlas:
	@$(GENERATOR) \
	$(PROTOBUF_ARGS) \
	$(PROJECT_ROOT)/pkg/pb/service.proto
	make protobuf-swagger-patch

.PHONY protobuf-swagger-patch:
protobuf-swagger-patch:
	@$(SWAGGER_GENERATOR) \
	--files $(PROJECT_ROOT)/pkg/pb/service.swagger.json \
	--with_custom_annotations \
	# Uncomment to enable private
	#--with_private

.PHONY vendor: vendor-atlas
vendor-atlas:
	@go mod tidy
	@go mod vendor
	@go mod download

.PHONY clean: clean-atlas
clean-atlas:
	@docker rmi -f $(shell docker images -q $(SERVER_IMAGE)) || true
	rm .push-* .docker-*

.PHONY migrate-up: migrate-up-atlas
migrate-up-atlas:
ifeq ($(WITH_DATABASE), true)
	@$(DOCKER_RUNNER) --net="host" $(MIGRATETOOL_IMAGE) --verbose --path=$(MIGRATION_PATH_IN_CONTAINER)/ --database.dsn=$(DATABASE_URL) up
else
	@echo "Your application doesn't have database, migrations aren't supported"
endif

.PHONY migrate-down: migrate-down-atlas
migrate-down-atlas:
ifeq ($(WITH_DATABASE), true)
	@$(DOCKER_RUNNER) --net="host" $(MIGRATETOOL_IMAGE) --verbose --path=$(MIGRATION_PATH_IN_CONTAINER)/ --database.dsn=$(DATABASE_URL) down
else
	@echo "Your application doesn't have database, migrations aren't supported"
endif

.PHONY: run-swagger-ui
run-swagger-ui:
ifeq ($(WITH_GATEWAY), true)
	(sleep 3; open http://127.0.0.1/ ) &
	docker run --rm -p 80:8080 \
		-e SWAGGER_JSON=/json/service.swagger.json \
		-v $(shell pwd)/pkg/pb/:/json \
		swaggerapi/swagger-ui
else
	@echo "Your application doesn't have swagger file"
endif

#configuration for helm
{{ if .WithHelm }}
helm-download:
	@if [ -f $(HELM) ]; then echo "$(HELM) is already downloaded, `$(HELM) version`"; else \
	mkdir -p bin; \
	echo "Downloading https://get.helm.sh/helm-${HELM_VERSION}-$(shell echo $(KERNEL_NAME) | tr A-Z a-z)-amd64.tar.gz"; \
	curl -Lo $(HELM).tar.gz https://get.helm.sh/helm-${HELM_VERSION}-$(shell echo $(KERNEL_NAME) | tr A-Z a-z)-amd64.tar.gz ; \
	cd bin; \
	tar -xzf helm.tar.gz ; \
	mv $(shell echo $(KERNEL_NAME) | tr A-Z a-z)-amd64/helm .; \
	rm -rf $(shell echo $(KERNEL_NAME) | tr A-Z a-z)-amd64; \
	rm helm.tar.gz; \
	cd ..; \
	chmod +x $(HELM); \
	fi

.PHONY: helm-lint
helm-lint: helm-download
	$(HELM) lint -f $(CHART_NAME)

.PHONY: helm-archive
helm-archive: helm-download
	$(HELM) package -d $(SRCROOT_ON_HOST) helm/$(CHART_NAME) --version $(CHART_VERSION)

.PHONY: helm-properties
helm-properties: helm/tpl.helm.properties
	@sed 's/{CHART_FILE}/$(CHART_FILE)/g' helm/tpl.helm.properties > helm.properties

.PHONY: push-chart
push-chart: helm-lint helm-archive helm-properties
	$(HELM) s3 push $(SRCROOT_IN_CONTAINER)/$(CHART_FILE) {{ .Registry }}

.PHONY: helm-install
helm-install: helm-download

.PHONY: helm-delete
helm-delete: helm-download
	$(HELM) delete --purge {{ .Helm.GetName }}

.PHONY: clean-chart
clean-chart:
	rm -f build.properties
	rm -f helm/*.tgz

package: $(CHART_FILE)

$(CHART_FILE): helm-download
	${HELM} package helm/$(CHART) --version $(CHART_VERSION)

build.properties: build.properties.in
	@sed 's/{CHART_FILE}/$(CHART_FILE)/g' build.properties.in > build.properties

.PHONY: show-image-version
show-image-version:
	@echo $(IMAGE_VERSION)
{{end}}
