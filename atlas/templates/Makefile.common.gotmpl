# this file was generated by atlas-cli
# changes to this file will be overriden by atlas-cli update
#
PROJECT_ROOT            ?= $(PWD)
BUILD_PATH              ?= bin
DOCKERFILE_PATH         ?= $(CURDIR)/docker

# configuration for image names
USERNAME                ?= $(USER)
GIT_COMMIT              ?= $(shell git describe --dirty=-unsupported --always --tags || echo pre-commit)
IMAGE_VERSION           ?= $(GIT_COMMIT)-$(USERNAME)

# configuration for server binary and image
SERVER_BINARY           ?= $(BUILD_PATH)/server
SERVER_PATH             ?= $(PROJECT_ROOT)/cmd/server
SERVER_DOCKERFILE       ?= $(DOCKERFILE_PATH)/Dockerfile

# configuration for the protobuf gentool
SRCROOT_ON_HOST         ?= $(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))
SRCROOT_IN_CONTAINER    ?= /go/src/$(PROJECT_ROOT)
DOCKER_RUNNER           ?= docker run -u `id -u`:`id -g` --rm -v $(SRCROOT_ON_HOST):$(SRCROOT_IN_CONTAINER)
DOCKER_GENERATOR        ?= infoblox/atlas-gentool:latest
GENERATOR               ?= $(DOCKER_RUNNER) $(DOCKER_GENERATOR)

# configuration for building on host machine
GO_CACHE                ?= -pkgdir $(BUILD_PATH)/go-cache
GO_BUILD_FLAGS          ?= $(GO_CACHE) -i -v
GO_TEST_FLAGS           ?= -v -cover
GO_PACKAGES             ?= $(shell go list ./... | grep -v vendor)


PROTOBUF_ARGS =  -I=$(PROJECT_ROOT)/vendor
PROTOBUF_ARGS += --go_out=plugins=grpc:.
PROTOBUF_ARGS += --validate_out="lang=go:."
WITH_DATABASE ?= false
WITH_GATEWAY  ?= false

GO_MOD = go.mod


ifeq ($(WITH_DATABASE), true)
PROTOBUF_ARGS += --gorm_out=.
endif

ifeq ($(WITH_GATEWAY), true)
PROTOBUF_ARGS += --grpc-gateway_out="logtostderr=true,allow_delete_body=true:."
PROTOBUF_ARGS += --swagger_out="atlas_patch=true,allow_delete_body=true:."
else ifeq ($(WITH_EXPAND), true)
PROTOBUF_ARGS += --grpc-gateway_out=logtostderr=true:.
endif

.PHONY all: all-atlas
all-atlas: vendor-atlas protobuf-atlas docker-atlas

.PHONY fmt: fmt-atlas
fmt-atlas:
	@go fmt $(GO_PACKAGES)

.PHONY test: test-atlas
test-atlas: fmt-atlas
	@go test $(GO_TEST_FLAGS) $(GO_PACKAGES)

docker-atlas:
	@docker build -f $(SERVER_DOCKERFILE) -t $(SERVER_IMAGE):$(IMAGE_VERSION) .
	@docker image prune -f --filter label=stage=server-intermediate

.docker-$(IMAGE_NAME)-$(IMAGE_VERSION):
	$(MAKE) docker-atlas
	touch $@

.PHONY: docker
docker: .docker-$(IMAGE_NAME)-$(IMAGE_VERSION)

push-atlas: docker
ifndef IMAGE_REGISTRY
	@(echo "Please set IMAGE_REGISTRY variable in Makefile.vars to use push command"; exit 1)
else
	@docker push $(SERVER_IMAGE):$(IMAGE_VERSION)
endif

.push-$(IMAGE_NAME)-$(IMAGE_VERSION):
	$(MAKE) push-atlas
	touch $@

.PHONY: push
push: .push-$(IMAGE_NAME)-$(IMAGE_VERSION)

.PHONY protobuf: protobuf-atlas
protobuf-atlas:
	@$(GENERATOR) \
	$(PROTOBUF_ARGS) \
	$(PROJECT_ROOT)/pkg/pb/service.proto

.PHONY vendor: vendor-atlas
vendor-atlas:
	@go mod tidy
	@go mod vendor
	@go mod download

.PHONY clean: clean-atlas
clean-atlas:
	@docker rmi -f $(shell docker images -q $(SERVER_IMAGE)) || true
	rm .push-* .docker-*

.PHONY migrate-up: migrate-up-atlas
migrate-up-atlas:
ifeq ($(WITH_DATABASE), true)
	@$(DOCKER_RUNNER) --net="host" $(MIGRATETOOL_IMAGE) --verbose --path=$(MIGRATION_PATH_IN_CONTAINER)/ --database.dsn=$(DATABASE_URL) up
else
	@echo "Your application doesn't have database, migrations aren't supported"
endif

.PHONY migrate-down: migrate-down-atlas
migrate-down-atlas:
ifeq ($(WITH_DATABASE), true)
	@$(DOCKER_RUNNER) --net="host" $(MIGRATETOOL_IMAGE) --verbose --path=$(MIGRATION_PATH_IN_CONTAINER)/ --database.dsn=$(DATABASE_URL) down
else
	@echo "Your application doesn't have database, migrations aren't supported"
endif

.PHONY: run-swagger-ui
run-swagger-ui:
ifeq ($(WITH_GATEWAY), true)
	(sleep 3; open http://127.0.0.1/ ) &
	docker run --rm -p 80:8080 \
		-e SWAGGER_JSON=/json/service.swagger.json \
		-v $(shell pwd)/pkg/pb/:/json \
		swaggerapi/swagger-ui
else
	@echo "Your application doesn't have swagger file"
endif

#configuration for helm
{{ if .WithHelm }}
.PHONY: helm-lint
helm-lint:
	cd helm && $(HELM) lint -f $(CHART_NAME)/minikube-values.yaml $(CHART_NAME)

.PHONY: helm-archive
helm-archive:
	$(HELM) package -d $(SRCROOT_ON_HOST) helm/$(CHART_NAME) --version $(CHART_VERSION)

.PHONY: helm-properties
helm-properties: helm/tpl.helm.properties
	@sed 's/{CHART_FILE}/$(CHART_FILE)/g' helm/tpl.helm.properties > helm.properties

.PHONY: push-chart
push-chart: helm-lint helm-archive helm-properties
	$(HELM) s3 push $(SRCROOT_IN_CONTAINER)/$(CHART_FILE) {{ .Registry }}

.PHONY: helm-install
helm-install: docker
	helm upgrade --install --set "image.tag=$(IMAGE_VERSION)" --devel --namespace {{ .Helm.GetName }} -f ./helm/{{ .Helm.GetName }}/minikube-values.yaml {{ .Helm.GetName }} ./helm/{{ .Helm.GetName }}/
	# You have to add host name minikube.local to hosts file. This is necessary to communicate with your app in minikube.
	# You might execute command in terminal:
	# 'echo "$(minikube ip) minikube.local" > /etc/hosts' or 'echo "$(minikube ip) minikube.local" | sudo tee -a /etc/hosts'

.PHONY: helm-delete
helm-delete:
	helm delete --purge {{ .Helm.GetName }}

{{end}}
